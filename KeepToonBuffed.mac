|****************************************************************************************************************
|   KeepToonBuffed - by Kroaking
|   based on KeepToonBuffed.mac by Kroaking
|   Last Updated: December 5th, 2025 - 03:15:00 PM
|
|   v2.0.5
|
|   This macro is designed to allow an out of group PowerLeveling toon
|   to be able to target members of a low level group, heal, 
|   and maintain buffs on them.
|
|  --- Credit goes out to Maskoi as well, for providing the CreateIni and LoadInI code -
|  --- (Ripped from ShamBot)
|
****************************************************************************************************************|
#turbo 80

#Event SpellBlocked "#*#Your #1# spell did not take hold on #2#. (Blocked by #3#.)#*#"
#Event SpellBlocked "#*#Your #1# spell did not take hold on #2#.#*#"

#define /message "/echo \ay[\atKeepToonBuffed\ay]\aw "
|---------------------------------------------------------------------------------
Sub Main

|---------------------------------------------------------------------------------
| ---- Turn off melee functions and turn on "Target Group Buff" setting ----------
/if (${Bool[${Plugin[MQ2Melee]}]}) /squelch /melee off
/squelch /target clear
|---------------------------------------------------------------------------------

|==================== DO NOT ALTER THESE VALUES ====================
/declare MacroName			string	outer	KeepToonBuffed
/declare KeepToonBuffVer	string	outer	2.0.5
/declare IniFileName		string	outer	${MacroName}_${Me.CleanName}.ini
/declare FirstRun			int		outer	0
/declare x					int		outer	0

|---------------------------------------
/if ( !${Ini[${IniFileName}].Length} ) {
	/call CreateIni
	/varset FirstRun 1
}
|---------------------------------------

| ################## Set up [General] values
/call LoadIni General MacroVer				string	${KeepToonBuffVer}
/call LoadIni General AutoAnnounce			bool	FALSE
/call LoadIni General Debug					bool	FALSE
/call LoadIni General AdminDebug			bool	FALSE
/call LoadIni General DebugINI				bool	FALSE
/call LoadIni General FollowGroup			bool	TRUE
/call LoadIni General FollowDist			int		30
/call LoadIni General DanNetDelay 			int 	20
/declare MyMDist 							int 	outer	${FollowDist}-5
/call LoadIni General SpellSetName			string	NULL

| ################## Set up [Mana] values
/call LoadIni Mana MinManaPct				int		20
/call LoadIni Mana MinManaMedPct			int		100

| ################## Set up [Heal] values
/call LoadIni Heal HealsOn					bool	TRUE
/call LoadIni Heal HealSpell				string	NULL
/call LoadIni Heal HealPct					int		60
/declare HealSpellRange 					int 	outer 	${Spell[${HealSpell}].Range}

| ################## Set up [Toons] values
/call LoadIni Toons NumberOfToons			int		6
/declare MyBuffTargetName[${NumberOfToons}]	string	outer 
/call LoadIni Toons MyBuffTargetName		string	NULL	MyBuffTargetName

| ################## Set up [Buffs] values
/call LoadIni Buffs BuffsOn					bool	TRUE
/call LoadIni Buffs NumberOfBuffs			int		5
/call LoadIni Buffs TargetBuffNameHelp 		string 	"Name of Spell to Cast|Name of Buff Effect in Buff Window"
/declare TargetBuffName[${NumberOfBuffs}]	string	outer
/call LoadIni Buffs TargetBuffName			string	NULL	TargetBuffName

| ################## Set up [Assist] values
/call LoadIni Assist AssistOn				bool	TRUE
/call LoadIni Assist AssistSpellHelp 		string 	"Name of Spell to Cast|Name of Buff Effect in Buff Window. Set SpamAssistSpell=1 if you want to continuously cast."
/call LoadIni Assist AssistSpell			string	"Ensnaring Roots"
/call LoadIni Assist AssistPct				int		60
/call LoadIni Assist SpamAssistSpell		bool	FALSE
	
|------------------------------------------------------------	
/if (${FirstRun}) {
	/message Created INI file ${IniFileName} with default values.
	/message Please edit the file and restart.
	/message Ending Macro.
	/end
} else {
	/message Config loaded from ${IniFileName}.
}
|------------------------------------------------------------

/call VersionControl
/call CheckPlugin MQ2Cast
/call CheckPlugin MQ2Nav
/call CheckPlugin MQ2DanNet

|--------------------------------------------------------------
/if (${FollowGroup} && !${Navigation.MeshLoaded}) {
	/message No nav mesh loaded! You will need a mesh for this zone in order for follow to work.
	/message Turning off FollowGroup.
	/varset FollowGroup 0
}
|--------------------------------------------------------------
|==================== DO NOT ALTER THESE VALUES ====================

|---------------------------------------------------------------------------------

	/message ==================================================================
	/message \ao${Macro}\ax - Version: \at${MacroVer}\ax by \agKroaking\aw
	/message \arOriginal macro by TreeHuginDruid (RIP)\aw
	/message ==================================================================
	/message \ag- FollowGroup \ayis set to \at[\ag${FollowGroup}\at]\aw
	/message \ag- FollowDist \ayis set to \at[\ag${FollowDist}\at]\aw
	/message \at----------------------------------------------------------------\aw
	/message \ag- SpellSetName \ayis set to \at[\ag${SpellSetName}\at]\aw
	/message \ag- HealsOn \ayis set to \at[\ag${HealsOn}\at]\aw
	/message \ag- HealPct \ayis set to \at[\ag${HealPct}\at]\aw
	/message \ag- HealSpell \ayis set to \at[\ag${HealSpell}\at]\aw
	/message \ag- HealSpellRange \ayis set to \at[\ag${HealSpellRange}\at]\aw
	/message \at----------------------------------------------------------------\aw
	/message \ag- NumberOfToons \ayis set to \at[\ag${NumberOfToons}\at]\aw
	|------------------------------
	/for x 1 to ${NumberOfToons}
		/message \ag- MyBuffTargetName\at${x}\ay\ao: is \at[\ag${MyBuffTargetName[${x}]}\at]\aw
	/next x
	|------------------------------
	/message \at----------------------------------------------------------------\aw	
	/message \ag- BuffsOn \ayis set to \at[\ag${BuffsOn}\at]\aw
	/message \ag- NumberOfBuffs \ayis set to \at[\ag${NumberOfBuffs}\at]\aw
	|------------------------------
	/for x 1 to ${NumberOfBuffs}
		/message \ag- TargetBuffName\at${x}\ay\ao: is \at[\ag${TargetBuffName[${x}]}\at]\aw
	/next x
	|------------------------------
	/message \at----------------------------------------------------------------\aw
	/message \ag- AssistOn \ayis set to \at[\ag${AssistOn}\at]\aw
	/message \ag- AssistPct \ayis set to \at[\ag${AssistPct}\at]\aw
	/message \ag- AssistSpell \ayis set to \at[\ag${AssistSpell}\at]\aw
	/message \ag- SpamAssistSpell \ayis set to \at[\ag${SpamAssistSpell}\at]\aw
	/message ==================================================================

|---------------------------------------------------------------------------------
/if (${Defined[SpellSetName]} && ${SpellSetName.NotEqual[NULL]}) {
    /message \awMemming spellset \am(\at${SpellSetName}\am)\aw.
	/message ==================================================================
    /memspellset ${SpellSetName}
    /delay 5s
}   
|---------------------------------------------------------------------------------

	/message \atGood to Go !!!\ax \ar--\ax \ayStarting routines . . .\aw
	/message ==================================================================

:loop 

    /if (${HealsOn})  /call CheckMyHealth
    /if (${HealsOn})  /call CheckTargetHealth
    /if (${BuffsOn})  /call MaintainTargetBuffs
    /if ((${Me.PctMana}<=${MinManaPct}) && !${Me.CombatState.Equal[COMBAT]}) /call CheckMana
    /if (${FollowGroup}) /call FollowAround
    /if (${AssistOn}) /call AssistOnTarget
    |Internal second delay to allow for manual moving, prevents constant sit loop if only 1 toon being buffed.
    /delay 10
    /if (${Me.Standing} && !${Me.Casting.ID} && !${Me.CombatState.Equal[COMBAT]} && !${Me.Moving} && !${Me.Mount.ID}) /sit 
  
/goto :loop

/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: VersionControl
|---------------------------------------------------------------------------------
Sub VersionControl
	/if (${MacroVer.NotEqual[${KeepToonBuffVer}]}) {
		/message \aoVersion mismatch detected, please wait until this is corrected.
		/ini "${IniFileName}" "General" "MacroVer" "${KeepToonBuffVer}"
		/message \agVersion information updated.
		/call LoadIni General MacroVer	string	${KeepToonBuffVer}
	}
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: CheckPlugin
|---------------------------------------------------------------------------------
Sub CheckPlugin(string pluginname)

/if (!${Bool[${Plugin[${pluginname}]}]}) {
    /squelch /plugin ${pluginname}
    /message \am(\ao${pluginname}\am)\aw plugin not detected! This macro requires it! \agLoading ...\aw
}
    
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: CreateIni
|---------------------------------------------------------------------------------
Sub CreateIni
	/if (${Ini[${IniFileName}].Length}) /return
	/declare a local General|Mana|Heal|Toons|Buffs|Assist
	/declare i int local 1
	/for i 1 to 6
	/ini ${IniFileName} "${a.Arg[${i},|]}" "|===================================" "==================================|"
	/next i

/return
|---------------------------------------------------------------------------------

|----------------------------------------------------------------------------------
| Ripped  off from kissassist with minimal modification -- some code is irrelevant
| ---------------------------------------------------------------------------------
Sub LoadIni(string sectionName, string varName, string varType, string varValue, string varArray, string FileName)
	/declare rkTemp                 string      local
	/declare UtilInt                int         local        0
	/declare FileName1              string      local        ${FileName}
	/declare RezCount               int         local        0
	| Assign ini name to default ini if not defined
	/if (${FileName1.Length}==0  || ${FileName1.Equal[NULL]}) {
		/varset FileName1 ${IniFileName}
	}
	| Check if ini value is asking for an array ie buff1 to buff20
	/if (${Bool[${varArray}]}) {
		/if (${${varArray}.Size}>0) {
			/declare i int local
			/for i 1 to ${${varArray}.Size}
				/if (${sectionName.NotEqual[KConditions]}) {
					/if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
						/ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
					} else {
						/varset ${varArray}[${i}] ${Ini[${FileName1},${sectionName},${varArray}${i}]}
					}
					/if (${${varArray}[${i}].NotEqual[NULL]} && ${${varArray}[${i}].Left[1].NotEqual[;]}) {

						| code to fix the Heal PCT for those zones Crypt of Sul, that knock your HPs down to
						/if (${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0) {
							/if (${sectionName.Equal[Heals]}) {
								/if (${${varArray}[${i}].Arg[3,|].Find[rez]}) {
									/varcalc RezCount ${RezCount}+1
									/if (${RezCount}<=${AutoRez.Size}) {
										/varset AutoRez[${RezCount}] ${${varArray}[${i}]}
										/varset ${varArray}[${i}] NULL
									}
								} else /if (${Select[${Zone.ID},795,796]}) {
									/varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}*.7
									/varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
								}
							} else /if (${sectionName.Equal[DPS]} && ${${varArray}[${i}].Arg[3,|].Equal[debuffall]}) {
								/varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
								/varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
							} else /if (${sectionName.Equal[Aggro]} && ${${varArray}[${i}].Arg[3,|].Equal[<<]}) {
								/varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
								/varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
							}
						} else /if (${sectionName.Equal[Heals]}) {
							/if (${${varArray}[${i}].Arg[3,|].Find[rez]}) {
								/varcalc RezCount ${RezCount}+1
								/if (${RezCount}<=${AutoRez.Size}) {
									/varset AutoRez[${RezCount}] ${${varArray}[${i}]}
									/varset ${varArray}[${i}] NULL
								}
							}
						}
					} else {
						/varset ${varArray}[${i}] NULL
					}
				} else {
					/if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
						/ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
					} else {
						/varset ${varArray}[${i}]  ${Ini[${FileName1},${sectionName},${varArray}${i},NULL,noparse]}
					}
				}
			/next i
			/return
		}
	} else {
		/if (!${Defined[${varName}]} && ${Select[${varType},string,float,int,bool]}>0) {
			/declare ${varName} ${varType} outer 0
			/if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
				/if (${varValue.Length}) {
					/ini "${FileName1}" "${sectionName}" "${varName}" "${varValue}"
					/varset ${varName} ${varValue}
				}
			} else {
				/varset ${varName} ${Ini[${FileName1},${sectionName},${varName}]}
			}
		}
	}
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: CheckMyHealth
|---------------------------------------------------------------------------------
Sub CheckMyHealth

/if (${Me.PctHPs}<=${HealPct}) {
    /if (${Target.ID}!=${Me.ID}) {
         /if (${Debug}) /message \awAttempting to target \am(\at${Me.CleanName}\am)\aw for heals!
         /squelch /target id ${Me.ID} pc targetable
         /delay 15 !${Target.ID}   
		 /message \awMy health is \am(\ao${Me.PctHPs}\am)\aw, healing myself with \am(\at${HealSpell}\am)\aw.
         /casting "${HealSpell}" gem8
         /call WaitSpellReady
    }
}

/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: CastSpell
|---------------------------------------------------------------------------------
Sub CastSpell(int SpellTarget, string SpellToCast)
	/if (${AdminDebug}) {
		/message \awCastSpell called with \am(\ay${SpellTarget}\ao, \ay${SpellToCast}\am)\aw
	}
	/squelch /target id ${SpellTarget}
	/delay 10 ${Target.ID}==${SpellTarget}
	/if (${Me.GemTimer[${Spell}]}==0 || ${Me.SpellReady[${SpellToCast}]}) {
		/cast "${SpellToCast}"
	}
	/delay 10
	/call WaitSpellReady
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: QueryHealth
|---------------------------------------------------------------------------------
Sub QueryHealth(string name)
	/declare result int local
	/dquery ${name} -q "Me.PctHPs" -o result -t ${DanNetDelay}
/return ${result}
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: CheckTargetHealth
|---------------------------------------------------------------------------------
Sub CheckTargetHealth

	/declare j int local
	/declare currentHealth int local

	/for j 1 to ${NumberOfToons}
		/if (${Spawn[=${MyBuffTargetName[${j}]}].ID} || (${Spawn[=${MyBuffTargetName[${j}]}].ID} && ${MyBuffTargetName[${j}].NotEqual[NULL]})) {
			/if (${Debug}) /message \aoAttempting to query \at \am(\at${MyBuffTargetName[${j}]}\am) \ao for \ag health \ao check.
			/call QueryHealth ${MyBuffTargetName[${j}]}
			/varset currentHealth ${Macro.Return}  

			/if ((${currentHealth}<=${HealPct}) && (${Target.Distance}<=${HealSpellRange}) && ${Cast.Ready["${HealSpell}"]}) {
				/message \am(\at${MyBuffTargetName[${j}]}'s\am)\aw health at \am(\ao${currentHealth}\am)\aw, -- \arHEAL TIME !!!\aw				
				/e3bct ${MyBuffTargetName[${j}]} /popcustom 14 2 + HEAL TIME !!!
				/call CastSpell ${Spawn[${MyBuffTargetName[${j}]}].ID} "${HealSpell}"
			}
		}
		
	/next j
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: QueryBuff
|---------------------------------------------------------------------------------
Sub QueryBuff(string Name, string Buff)
	/declare HasBuff int local 0
	/declare HasSong int local 0
	/declare Result int local 0
	/dquery ${Name} -q "Me.Buff[${Buff}].ID" -o HasBuff -t ${DanNetDelay}
	/dquery ${Name} -q "Me.Song[${Buff}].ID" -o HasSong -t ${DanNetDelay}
	/varcalc Result ${HasBuff} || ${HasSong}
/return ${Result}
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: MaintainTargetBuffs
|---------------------------------------------------------------------------------
Sub MaintainTargetBuffs

	/declare i int local
	/declare j int local

	/declare SpellToCast string local 0
	/declare BuffIDName  string local 0

	/for j 1 to ${NumberOfToons}
		/if (${Spawn[=${MyBuffTargetName[${j}]}].ID} || (${Spawn[=${MyBuffTargetName[${j}]}].ID} && ${MyBuffTargetName[${j}].NotEqual[NULL]})) {
			/if (${Debug}) /message \aoAttempting to query \at \am(\at${MyBuffTargetName[${j}]}\am) \ao for \ag buff \ao check.

		 |--------------------------------------------------------------------------------
			 /for i 1 to ${NumberOfBuffs} 
				|--------------------------------------------------------------------------------
				|If spell name differs from buff name, use argument seperator to extract and set values. 
					/if (${TargetBuffName[${i}].Arg[2,|].Length}) {
						/varset SpellToCast ${TargetBuffName[${i}].Arg[1,|]}
						/varset BuffIDName  ${TargetBuffName[${i}].Arg[2,|]}
					} else {
						/varset SpellToCast ${TargetBuffName[${i}]}
						/varset BuffIDName  ${TargetBuffName[${i}]}
					}
					|--
					/if (${SpellToCast.Equal[NULL]}) /continue										
					|--
					/call QueryBuff "${MyBuffTargetName[${j}]}" "${BuffIDName}"	
					/if (!${Macro.Return} && ${Cast.Ready["${SpellToCast}"]}) {										
						/message \awBuffing \am(\at${MyBuffTargetName[${j}]}\am)\aw with \am(\ag${SpellToCast}\am)\aw.
						/e3bct ${MyBuffTargetName[${j}]} /popcustom 18 2 + Buffing: (${SpellToCast})
						/call CastSpell ${Spawn[=${MyBuffTargetName[${j}]}].ID} "${SpellToCast}"
					}
			/next i
			|--------------------------------------------------------------------------------
		}
	/next j
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: QueryShouldAssist
|---------------------------------------------------------------------------------
Sub QueryShouldAssist(string Name, string BuffIDName)
	/declare TargetHP int local
	/declare TargetType string local
	/declare TargetID int local
	/declare InCombat string local
	/declare AlreadyDebuffed int local

	/dquery ${Name} -q "Target.PctHPs" -o TargetHP -t ${DanNetDelay}
	/dquery ${Name} -q "Target.Type" -o TargetType -t ${DanNetDelay}
	/dquery ${Name} -q "Target.ID" -o TargetID -t ${DanNetDelay}
	/dquery ${Name} -q "Me.CombatState.Equal[COMBAT]" -o InCombat -t ${DanNetDelay}
	/if (${SpamAssistSpell}) {
		/varset AlreadyDebuffed 0
	} else {
		/dquery ${Name} -q "Target.Buff[${BuffIDName}].ID" -o AlreadyDebuffed -t ${DanNetDelay}
	}
    /if (${Select[${TargetType},NPC,PET]} && ${InCombat} && ${TargetHP} < ${AssistPct} && !${AlreadyDebuffed}) {
		/return ${TargetID}
	} else /return 0
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: AssistOnTarget
|---------------------------------------------------------------------------------
Sub AssistOnTarget
	/declare SpellToCast 	string 	local 0
	/declare BuffIDName 	string 	local 0
	/declare y				int 	local 0

	|If spell name differs from buff name, use argument seperator to extract and set values. 
	/if (${AssistSpell.Arg[2,|].Length}) {
		/varset SpellToCast ${AssistSpell.Arg[1,|]}
		/varset BuffIDName  ${AssistSpell.Arg[2,|]}
	} else {
		/varset SpellToCast ${AssistSpell}
		/varset BuffIDName  ${AssistSpell}
	}   

	/declare TargetID int local 0
	/call QueryShouldAssist "${MyBuffTargetName[1]}" "${BuffIDName}"
	/varset TargetID ${Macro.Return}
	/if (${TargetID} > 0 && ${Cast.Ready["${SpellToCast}"]}) {
		/message \awAttempting to assist, casting \am(\ay${SpellToCast}\am) \awon \am(\ar${Spawn[${TargetID}].CleanName}\am)\aw.
		|---------------------------
		/for y 1 to ${NumberOfToons}
			/e3bct ${MyBuffTargetName[${y}]} /popcustom 15 2 + Casting (${SpellToCast}) on (${Spawn[${TargetID}].CleanName})
		/next y		
		|---------------------------
		/call CastSpell ${TargetID} "${SpellToCast}"
	}
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: CheckMana
|---------------------------------------------------------------------------------
Sub CheckMana
	/if (${Select[${Me.Class.ShortName},BRD]}) /return
	/message \awChecking my Mana . . .
	/if (${Me.PctMana}<${MinManaMedPct}) { 
		 /message \ayI'm low on mana \am(\at${Me.PctMana}%\am)\ay, medding to \am(\at${MinManaMedPct}%\am)\ay.
		 /if (${AutoAnnounce}) /tell ${MyBuffTargetName[1]} I'm low on mana, medding to full.      

		 /if (${Me.Standing} && !${Me.Mount.ID}) /sit 

		:KeepMeddingForMana
		/if (!${Me.CombatState.Equal[COMBAT]} && (${Me.PctMana}<${MinManaMedPct})) {
			/message \ayMana now at \am(\at${Me.PctMana}%\am)\ay ...
			/if (${Me.AltAbilityReady[Cannibalization]}) /call Cast "Cannibalization" alt  	 	
			/if (${HealsOn})  /call CheckMyHealth
			/if (${HealsOn})  /call CheckTargetHealth
			/if (${BuffsOn})  /call MaintainTargetBuffs 
			/if (${FollowGroup}) /call FollowAround
			/delay 6s
			/doevents        
			/if (${Me.Standing} && !${Me.Mount.ID}) /sit
			/goto :KeepMeddingForMana
		} else {
			/if (${Me.Sitting} && !${Me.Mount.ID}) /stand
		}
		 
		/message \awMana check done . . .
		/if (${AutoAnnounce}) /tell ${MyBuffTargetName[1]} Done medding!
	}
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: FollowAround
|---------------------------------------------------------------------------------
Sub FollowAround
	/declare FollowID int local ${Spawn[=${MyBuffTargetName[1]}].ID}

	/if (${AdminDebug}) {
		 /message \awFollowAround\ao: \am(\at${FollowGroup}\am) \awFollowDIst\ao: \am(\at${FollowDist}\am)\aw.
	}

	/if (${Spawn[${FollowID}].Distance3D} > ${FollowDist}) {
		/message \awMoving closer to \am(\at${MyBuffTargetName[1]}\am)\ax.
		/squelch /nav id ${FollowID}
		/delay 1
		
		/while (${Spawn[${FollowID}].Distance3D} > ${FollowDist} && ${Navigation.Active}) {
			 /delay 1
		}
		/nav stop
	}
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: WaitSpellReady
|---------------------------------------------------------------------------------
Sub WaitSpellReady
	/while ( !${Cast.Ready}) {
		/delay 1
	}
/return
|---------------------------------------------------------------------------------

|---------------------------------------------------------------------------------
| SUB: Event_SpellBlocked
|---------------------------------------------------------------------------------
Sub Event_SpellBlocked(string line, string MySPell, string BuffToon, string BlockingSPell)

/if (${Defined[${BlockingSPell}]}) {
    /message \awYour \ar(\at${MySPell}\ar)\aw spell did not take hold on \am(\at${BuffToon}\am) (\awBlocked by \ar${BlockingSPell}\am)\aw.
} else {
    /message \awYour \ar(\at${MySPell}\ar)\aw spell did not take hold on \am(\at${BuffToon}\am) (\awPerhaps he/she is max buffed?\am)\aw.
}
/beep
/message You are wasting mana in a casting loop!
    
/return
|---------------------------------------------------------------------------------